#include "utils.h"#include <thrust/execution_policy.h>#include <thrust/scan.h>template <typename scalar_t>__global__ void composite_train_fw_kernel(    const torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> sigmas,    const torch::PackedTensorAccessor<scalar_t, 2, torch::RestrictPtrTraits, size_t> rgbs,    const torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> deltas,    const torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> ts,    const torch::PackedTensorAccessor64<int64_t, 2, torch::RestrictPtrTraits> rays_a,    const scalar_t T_threshold,    torch::PackedTensorAccessor64<int64_t, 1, torch::RestrictPtrTraits> total_samples,    torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> opacity,    torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> depth,    torch::PackedTensorAccessor<scalar_t, 2, torch::RestrictPtrTraits, size_t> rgb,    torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> ws){    const int n = blockIdx.x * blockDim.x + threadIdx.x;    if (n >= opacity.size(0)) return;    const int ray_idx = rays_a[n][0], start_idx = rays_a[n][1], N_samples = rays_a[n][2];    // front to back compositing    int samples = 0; scalar_t T = 1.0f;    while (samples < N_samples) {        const int s = start_idx + samples;        const scalar_t a = 1.0f - __expf(-sigmas[s]*deltas[s]);        const scalar_t w = a * T; // weight of the sample point        rgb[ray_idx][0] += w*rgbs[s][0];        rgb[ray_idx][1] += w*rgbs[s][1];        rgb[ray_idx][2] += w*rgbs[s][2];        depth[ray_idx] += w*ts[s];        opacity[ray_idx] += w;        ws[s] = w;        T *= 1.0f-a;        if (T <= T_threshold) break; // ray has enough opacity        samples++;    }    total_samples[ray_idx] = samples;}std::vector<torch::Tensor> composite_train_fw_cu(    const torch::Tensor sigmas,    const torch::Tensor rgbs,    const torch::Tensor deltas,    const torch::Tensor ts,    const torch::Tensor rays_a,    const float T_threshold){    const int N_rays = rays_a.size(0), N = sigmas.size(0);    auto opacity = torch::zeros({N_rays}, sigmas.options());    auto depth = torch::zeros({N_rays}, sigmas.options());    auto rgb = torch::zeros({N_rays, 3}, sigmas.options());    auto ws = torch::zeros({N}, sigmas.options());    auto total_samples = torch::zeros({N_rays}, torch::dtype(torch::kLong).device(sigmas.device()));    const int threads = 256, blocks = (N_rays+threads-1)/threads;    AT_DISPATCH_FLOATING_TYPES_AND_HALF(sigmas.type(), "composite_train_fw_cu",     ([&] {        composite_train_fw_kernel<scalar_t><<<blocks, threads>>>(            sigmas.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            rgbs.packed_accessor<scalar_t, 2, torch::RestrictPtrTraits, size_t>(),            deltas.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            ts.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            rays_a.packed_accessor64<int64_t, 2, torch::RestrictPtrTraits>(),            T_threshold,            total_samples.packed_accessor64<int64_t, 1, torch::RestrictPtrTraits>(),            opacity.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            depth.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            rgb.packed_accessor<scalar_t, 2, torch::RestrictPtrTraits, size_t>(),            ws.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>()        );    }));    return {total_samples, opacity, depth, rgb, ws};}template <typename scalar_t>__global__ void composite_train_bw_kernel(    const torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> dL_dopacity,    const torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> dL_ddepth,    const torch::PackedTensorAccessor<scalar_t, 2, torch::RestrictPtrTraits, size_t> dL_drgb,    const torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> dL_dws,    scalar_t* __restrict__ dL_dws_times_ws,    const torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> sigmas,    const torch::PackedTensorAccessor<scalar_t, 2, torch::RestrictPtrTraits, size_t> rgbs,    const torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> deltas,    const torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> ts,    const torch::PackedTensorAccessor64<int64_t, 2, torch::RestrictPtrTraits> rays_a,    const torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> opacity,    const torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> depth,    const torch::PackedTensorAccessor<scalar_t, 2, torch::RestrictPtrTraits, size_t> rgb,    const scalar_t T_threshold,    torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> dL_dsigmas,    torch::PackedTensorAccessor<scalar_t, 2, torch::RestrictPtrTraits, size_t> dL_drgbs){    const int n = blockIdx.x * blockDim.x + threadIdx.x;    if (n >= opacity.size(0)) return;    const int ray_idx = rays_a[n][0], start_idx = rays_a[n][1], N_samples = rays_a[n][2];    // front to back compositing    int samples = 0;    scalar_t R = rgb[ray_idx][0], G = rgb[ray_idx][1], B = rgb[ray_idx][2];    scalar_t O = opacity[ray_idx], D = depth[ray_idx];    scalar_t T = 1.0f, r = 0.0f, g = 0.0f, b = 0.0f, d = 0.0f;    // compute prefix sum of dL_dws * ws    // [a0, a1, a2, a3, ...] -> [a0, a0+a1, a0+a1+a2, a0+a1+a2+a3, ...]    thrust::inclusive_scan(thrust::device,                           dL_dws_times_ws+start_idx,                           dL_dws_times_ws+start_idx+N_samples,                           dL_dws_times_ws+start_idx);    scalar_t dL_dws_times_ws_sum = dL_dws_times_ws[start_idx+N_samples-1];    while (samples < N_samples) {        const int s = start_idx + samples;        const scalar_t a = 1.0f - __expf(-sigmas[s]*deltas[s]);        const scalar_t w = a * T;        r += w*rgbs[s][0]; g += w*rgbs[s][1]; b += w*rgbs[s][2];        d += w*ts[s];        T *= 1.0f-a;        // compute gradients by math...        dL_drgbs[s][0] = dL_drgb[ray_idx][0]*w;        dL_drgbs[s][1] = dL_drgb[ray_idx][1]*w;        dL_drgbs[s][2] = dL_drgb[ray_idx][2]*w;        dL_dsigmas[s] = deltas[s] * (            dL_drgb[ray_idx][0]*(rgbs[s][0]*T-(R-r)) +             dL_drgb[ray_idx][1]*(rgbs[s][1]*T-(G-g)) +             dL_drgb[ray_idx][2]*(rgbs[s][2]*T-(B-b)) + // gradients from rgb            dL_dopacity[ray_idx]*(1-O) + // gradient from opacity            dL_ddepth[ray_idx]*(ts[s]*T-(D-d)) + // gradient from depth            T*dL_dws[s]-(dL_dws_times_ws_sum-dL_dws_times_ws[s]) // gradient from ws        );        if (T <= T_threshold) break; // ray has enough opacity        samples++;    }}std::vector<torch::Tensor> composite_train_bw_cu(    const torch::Tensor dL_dopacity,    const torch::Tensor dL_ddepth,    const torch::Tensor dL_drgb,    const torch::Tensor dL_dws,    const torch::Tensor sigmas,    const torch::Tensor rgbs,    const torch::Tensor ws,    const torch::Tensor deltas,    const torch::Tensor ts,    const torch::Tensor rays_a,    const torch::Tensor opacity,    const torch::Tensor depth,    const torch::Tensor rgb,    const float T_threshold){    const int N = sigmas.size(0), N_rays = rays_a.size(0);    auto dL_dsigmas = torch::zeros({N}, sigmas.options());    auto dL_drgbs = torch::zeros({N, 3}, sigmas.options());    auto dL_dws_times_ws = dL_dws * ws; // auxiliary input    const int threads = 256, blocks = (N_rays+threads-1)/threads;    AT_DISPATCH_FLOATING_TYPES_AND_HALF(sigmas.type(), "composite_train_bw_cu",     ([&] {        composite_train_bw_kernel<scalar_t><<<blocks, threads>>>(            dL_dopacity.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            dL_ddepth.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            dL_drgb.packed_accessor<scalar_t, 2, torch::RestrictPtrTraits, size_t>(),            dL_dws.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            dL_dws_times_ws.data_ptr<scalar_t>(),            sigmas.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            rgbs.packed_accessor<scalar_t, 2, torch::RestrictPtrTraits, size_t>(),            deltas.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            ts.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            rays_a.packed_accessor64<int64_t, 2, torch::RestrictPtrTraits>(),            opacity.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            depth.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            rgb.packed_accessor<scalar_t, 2, torch::RestrictPtrTraits, size_t>(),            T_threshold,            dL_dsigmas.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            dL_drgbs.packed_accessor<scalar_t, 2, torch::RestrictPtrTraits, size_t>()        );    }));    return {dL_dsigmas, dL_drgbs};}template <typename scalar_t>__global__ void composite_train_transient_fw_kernel(    const torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> static_sigmas,    const torch::PackedTensorAccessor<scalar_t, 2, torch::RestrictPtrTraits, size_t> static_rgbs,    const torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> transient_sigmas,    const torch::PackedTensorAccessor<scalar_t, 2, torch::RestrictPtrTraits, size_t> transient_rgbs,    const torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> transient_betas,    const torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> deltas,    const torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> ts,    const torch::PackedTensorAccessor64<int64_t, 2, torch::RestrictPtrTraits> rays_a,    const scalar_t T_threshold,    torch::PackedTensorAccessor64<int64_t, 1, torch::RestrictPtrTraits> total_samples,    torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> opacity,    torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> depth,    torch::PackedTensorAccessor<scalar_t, 2, torch::RestrictPtrTraits, size_t> static_rgb,    torch::PackedTensorAccessor<scalar_t, 2, torch::RestrictPtrTraits, size_t> transient_rgb,    torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> transient_beta,    torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> ws,    torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> static_ws,    torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> transient_ws){    const int n = blockIdx.x * blockDim.x + threadIdx.x;    if (n >= opacity.size(0)) return;    const int ray_idx = rays_a[n][0], start_idx = rays_a[n][1], N_samples = rays_a[n][2];    // front to back compositing    int samples = 0; scalar_t T = 1.0f;    while (samples < N_samples) {        const int s = start_idx + samples;        const scalar_t a = 1.0f - __expf(-(static_sigmas[s]+transient_sigmas[s])*deltas[s]);        const scalar_t s_a = 1.0f - __expf(-static_sigmas[s]*deltas[s]);        const scalar_t t_a = 1.0f - __expf(-transient_sigmas[s]*deltas[s]);        const scalar_t w = a * T; // weight of the sample point        const scalar_t s_w = s_a * T;        const scalar_t t_w = t_a * T;        static_rgb[ray_idx][0] += s_w*static_rgbs[s][0];        static_rgb[ray_idx][1] += s_w*static_rgbs[s][1];        static_rgb[ray_idx][2] += s_w*static_rgbs[s][2];        transient_rgb[ray_idx][0] += t_w*transient_rgbs[s][0];        transient_rgb[ray_idx][1] += t_w*transient_rgbs[s][1];        transient_rgb[ray_idx][2] += t_w*transient_rgbs[s][2];        transient_beta[ray_idx] += t_w*transient_betas[s];        depth[ray_idx] += w*ts[s];        opacity[ray_idx] += w;        ws[s] = w;        static_ws[s] = w;        transient_ws[s] = w;        T *= 1.0f-a;        if (T <= T_threshold) break; // ray has enough opacity        samples++;    }    total_samples[ray_idx] = samples;}std::vector<torch::Tensor> composite_train_transient_fw_cu(    const torch::Tensor static_sigmas,    const torch::Tensor static_rgbs,    const torch::Tensor transient_sigmas,    const torch::Tensor transient_rgbs,    const torch::Tensor transient_betas,    const torch::Tensor deltas,    const torch::Tensor ts,    const torch::Tensor rays_a,    const float T_threshold){    const int N_rays = rays_a.size(0), N = static_sigmas.size(0);    auto total_samples = torch::zeros({N_rays}, torch::dtype(torch::kLong).device(static_sigmas.device()));    auto opacity = torch::zeros({N_rays}, static_sigmas.options());    auto depth = torch::zeros({N_rays}, static_sigmas.options());    auto static_rgb = torch::zeros({N_rays, 3}, static_sigmas.options());    auto transient_rgb = torch::zeros({N_rays, 3}, static_sigmas.options());    auto transient_beta = torch::zeros({N_rays}, static_sigmas.options());    auto ws = torch::zeros({N}, static_sigmas.options());    auto static_ws = torch::zeros({N}, static_sigmas.options());    auto transient_ws = torch::zeros({N}, static_sigmas.options());    const int threads = 256, blocks = (N_rays+threads-1)/threads;    AT_DISPATCH_FLOATING_TYPES_AND_HALF(static_sigmas.type(), "composite_train_transient_fw_cu",    ([&] {        composite_train_transient_fw_kernel<scalar_t><<<blocks, threads>>>(            static_sigmas.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            static_rgbs.packed_accessor<scalar_t, 2, torch::RestrictPtrTraits, size_t>(),            transient_sigmas.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            transient_rgbs.packed_accessor<scalar_t, 2, torch::RestrictPtrTraits, size_t>(),            transient_betas.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            deltas.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            ts.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            rays_a.packed_accessor64<int64_t, 2, torch::RestrictPtrTraits>(),            T_threshold,            total_samples.packed_accessor64<int64_t, 1, torch::RestrictPtrTraits>(),            opacity.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            depth.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            static_rgb.packed_accessor<scalar_t, 2, torch::RestrictPtrTraits, size_t>(),            transient_rgb.packed_accessor<scalar_t, 2, torch::RestrictPtrTraits, size_t>(),            transient_beta.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            ws.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            static_ws.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            transient_ws.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>()        );    }));    return {total_samples, opacity, depth, static_rgb, transient_rgb, transient_beta, ws, static_ws, transient_ws};}template <typename scalar_t>__global__ void composite_train_transient_bw_kernel(    const torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> dL_dopacity,    const torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> dL_ddepth,    const torch::PackedTensorAccessor<scalar_t, 2, torch::RestrictPtrTraits, size_t> dL_dstatic_rgb,    const torch::PackedTensorAccessor<scalar_t, 2, torch::RestrictPtrTraits, size_t> dL_dtransient_rgb,    const torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> dL_dtransient_beta,    const torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> dL_dws,    const torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> dL_dstatic_ws,    const torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> dL_dtransient_ws,    scalar_t* __restrict__ dL_dws_times_ws,    scalar_t* __restrict__ dL_dstatic_ws_times_static_ws,    scalar_t* __restrict__ dL_dtransient_ws_times_transient_ws,    const torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> static_sigmas,    const torch::PackedTensorAccessor<scalar_t, 2, torch::RestrictPtrTraits, size_t> static_rgbs,    const torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> transient_sigmas,    const torch::PackedTensorAccessor<scalar_t, 2, torch::RestrictPtrTraits, size_t> transient_rgbs,    const torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> transient_betas,    const torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> deltas,    const torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> ts,    const torch::PackedTensorAccessor64<int64_t, 2, torch::RestrictPtrTraits> rays_a,    const torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> opacity,    const torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> depth,    const torch::PackedTensorAccessor<scalar_t, 2, torch::RestrictPtrTraits, size_t> static_rgb,    const torch::PackedTensorAccessor<scalar_t, 2, torch::RestrictPtrTraits, size_t> transient_rgb,    const torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> transient_beta,    const scalar_t T_threshold,    torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> dL_dstatic_sigmas,    torch::PackedTensorAccessor<scalar_t, 2, torch::RestrictPtrTraits, size_t> dL_dstatic_rgbs,    torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> dL_dtransient_sigmas,    torch::PackedTensorAccessor<scalar_t, 2, torch::RestrictPtrTraits, size_t> dL_dtransient_rgbs,    torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> dL_dtransient_betas){    const int n = blockIdx.x * blockDim.x + threadIdx.x;    if (n >= opacity.size(0)) return;    const int ray_idx = rays_a[n][0], start_idx = rays_a[n][1], N_samples = rays_a[n][2];    // front to back compositing    int samples = 0;    scalar_t S_R = static_rgb[ray_idx][0], S_G = static_rgb[ray_idx][1], S_B = static_rgb[ray_idx][2];    scalar_t T_R = transient_rgb[ray_idx][0], T_G = transient_rgb[ray_idx][1], T_B = transient_rgb[ray_idx][2];    scalar_t T_BETA = transient_beta[ray_idx];    scalar_t O = opacity[ray_idx], D = depth[ray_idx];    scalar_t T = 1.0f, s_r = 0.0f, s_g = 0.0f, s_b = 0.0f, t_r = 0.0f, t_g = 0.0f, t_b = 0.0f, t_beta = 0.0f, d = 0.0f;    thrust::inclusive_scan(thrust::device,                           dL_dstatic_ws_times_static_ws+start_idx,                           dL_dstatic_ws_times_static_ws+start_idx+N_samples,                           dL_dstatic_ws_times_static_ws+start_idx);    scalar_t dL_dstatic_ws_times_static_ws_sum = dL_dstatic_ws_times_static_ws[start_idx+N_samples-1];    thrust::inclusive_scan(thrust::device,                           dL_dtransient_ws_times_transient_ws+start_idx,                           dL_dtransient_ws_times_transient_ws+start_idx+N_samples,                           dL_dtransient_ws_times_transient_ws+start_idx);    scalar_t dL_dtransient_ws_times_transient_ws_sum = dL_dtransient_ws_times_transient_ws[start_idx+N_samples-1];    while (samples < N_samples) {        const int s = start_idx + samples;        const scalar_t a = 1.0f - __expf(-(static_sigmas[s]+transient_sigmas[s])*deltas[s]);        const scalar_t s_a = 1.0f - __expf(-static_sigmas[s]*deltas[s]);        const scalar_t t_a = 1.0f - __expf(-transient_sigmas[s]*deltas[s]);        const scalar_t w = a * T;        const scalar_t s_w = s_a * T;        const scalar_t t_w = t_a * T;        s_r += s_w*static_rgbs[s][0]; s_g += s_w*static_rgbs[s][1]; s_b += s_w*static_rgbs[s][2];        t_r += t_w*transient_rgbs[s][0]; t_g += t_w*transient_rgbs[s][1]; t_b += t_w*transient_rgbs[s][2];        t_beta += t_w*transient_betas[s];        d += w*ts[s];        T *= 1.0f-a;        // compute gradients by math...        dL_dstatic_rgbs[s][0] = dL_dstatic_rgb[ray_idx][0]*s_w;        dL_dstatic_rgbs[s][1] = dL_dstatic_rgb[ray_idx][1]*s_w;        dL_dstatic_rgbs[s][2] = dL_dstatic_rgb[ray_idx][2]*s_w;        dL_dtransient_rgbs[s][0] = dL_dtransient_rgb[ray_idx][0]*t_w;        dL_dtransient_rgbs[s][1] = dL_dtransient_rgb[ray_idx][1]*t_w;        dL_dtransient_rgbs[s][2] = dL_dtransient_rgb[ray_idx][2]*t_w;        dL_dtransient_betas[s] = dL_dtransient_beta[ray_idx]*t_w;        dL_dstatic_sigmas[s] = deltas[s] * (            dL_dstatic_rgb[ray_idx][0]*(static_rgbs[s][0]*T-(S_R-s_r)) +            dL_dstatic_rgb[ray_idx][1]*(static_rgbs[s][1]*T-(S_G-s_g)) +            dL_dstatic_rgb[ray_idx][2]*(static_rgbs[s][2]*T-(S_B-s_b)) + // gradients from rgb            dL_dopacity[ray_idx]*(1-O) + // gradient from opacity            dL_ddepth[ray_idx]*(ts[s]*T-(D-d)) + // gradient from depth            T*dL_dstatic_ws[s]-(dL_dstatic_ws_times_static_ws_sum-dL_dstatic_ws_times_static_ws[s]) // gradient from static_ws        );        dL_dtransient_sigmas[s] = deltas[s] * (            dL_dtransient_rgb[ray_idx][0]*(transient_rgbs[s][0]*T-(T_R-t_r)) +            dL_dtransient_rgb[ray_idx][1]*(transient_rgbs[s][1]*T-(T_G-t_g)) +            dL_dtransient_rgb[ray_idx][2]*(transient_rgbs[s][2]*T-(T_B-t_b)) + // gradients from rgb            dL_dtransient_beta[ray_idx]*(transient_betas[s]*T-(T_BETA-t_beta)) + // gradients from beta            dL_dopacity[ray_idx]*(1-O) + // gradient from opacity            dL_ddepth[ray_idx]*(ts[s]*T-(D-d)) + // gradient from depth            T*dL_dtransient_ws[s]-(dL_dtransient_ws_times_transient_ws_sum-dL_dtransient_ws_times_transient_ws[s]) // gradient from static_ws        );        if (T <= T_threshold) break; // ray has enough opacity        samples++;    }}std::vector<torch::Tensor> composite_train_transient_bw_cu(    const torch::Tensor dL_dopacity,    const torch::Tensor dL_ddepth,    const torch::Tensor dL_dstatic_rgb,    const torch::Tensor dL_dtransient_rgb,    const torch::Tensor dL_dtransient_beta,    const torch::Tensor dL_dws,    const torch::Tensor dL_dstatic_ws,    const torch::Tensor dL_dtransient_ws,    const torch::Tensor static_sigmas,    const torch::Tensor static_rgbs,    const torch::Tensor transient_sigmas,    const torch::Tensor transient_rgbs,    const torch::Tensor transient_betas,    const torch::Tensor ws,    const torch::Tensor static_ws,    const torch::Tensor transient_ws,    const torch::Tensor deltas,    const torch::Tensor ts,    const torch::Tensor rays_a,    const torch::Tensor opacity,    const torch::Tensor depth,    const torch::Tensor static_rgb,    const torch::Tensor transient_rgb,    const torch::Tensor transient_beta,    const float T_threshold){    const int N = static_sigmas.size(0), N_rays = rays_a.size(0);    auto dL_dstatic_sigmas = torch::zeros({N}, static_sigmas.options());    auto dL_dstatic_rgbs = torch::zeros({N, 3}, static_sigmas.options());    auto dL_dtransient_sigmas = torch::zeros({N}, transient_sigmas.options());    auto dL_dtransient_rgbs = torch::zeros({N, 3}, transient_sigmas.options());    auto dL_dtransient_betas = torch::zeros({N}, transient_sigmas.options());    auto dL_dws_times_ws = dL_dws * ws; // auxiliary input    auto dL_dstatic_ws_times_static_ws = dL_dstatic_ws * static_ws;    auto dL_dtransient_ws_times_transient_ws = dL_dtransient_ws * transient_ws;    const int threads = 256, blocks = (N_rays+threads-1)/threads;    AT_DISPATCH_FLOATING_TYPES_AND_HALF(static_sigmas.type(), "composite_train_transient_bw_cu",    ([&] {        composite_train_transient_bw_kernel<scalar_t><<<blocks, threads>>>(            dL_dopacity.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            dL_ddepth.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            dL_dstatic_rgb.packed_accessor<scalar_t, 2, torch::RestrictPtrTraits, size_t>(),            dL_dtransient_rgb.packed_accessor<scalar_t, 2, torch::RestrictPtrTraits, size_t>(),            dL_dtransient_beta.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            dL_dws.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            dL_dstatic_ws.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            dL_dtransient_ws.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            dL_dws_times_ws.data_ptr<scalar_t>(),            dL_dstatic_ws_times_static_ws.data_ptr<scalar_t>(),            dL_dtransient_ws_times_transient_ws.data_ptr<scalar_t>(),            static_sigmas.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            static_rgbs.packed_accessor<scalar_t, 2, torch::RestrictPtrTraits, size_t>(),            transient_sigmas.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            transient_rgbs.packed_accessor<scalar_t, 2, torch::RestrictPtrTraits, size_t>(),            transient_betas.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            deltas.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            ts.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            rays_a.packed_accessor64<int64_t, 2, torch::RestrictPtrTraits>(),            opacity.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            depth.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            static_rgb.packed_accessor<scalar_t, 2, torch::RestrictPtrTraits, size_t>(),            transient_rgb.packed_accessor<scalar_t, 2, torch::RestrictPtrTraits, size_t>(),            transient_beta.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            T_threshold,            dL_dstatic_sigmas.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            dL_dstatic_rgbs.packed_accessor<scalar_t, 2, torch::RestrictPtrTraits, size_t>(),            dL_dtransient_sigmas.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            dL_dtransient_rgbs.packed_accessor<scalar_t, 2, torch::RestrictPtrTraits, size_t>(),            dL_dtransient_betas.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>()        );    }));    return {dL_dstatic_sigmas, dL_dstatic_rgbs, dL_dtransient_sigmas, dL_dtransient_rgbs, dL_dtransient_betas};}/////////////////////   test only have backward //////////////////////////////template <typename scalar_t>__global__ void composite_test_fw_kernel(    const torch::PackedTensorAccessor<scalar_t, 2, torch::RestrictPtrTraits, size_t> sigmas,    const torch::PackedTensorAccessor<scalar_t, 3, torch::RestrictPtrTraits, size_t> rgbs,    const torch::PackedTensorAccessor<scalar_t, 2, torch::RestrictPtrTraits, size_t> deltas,    const torch::PackedTensorAccessor<scalar_t, 2, torch::RestrictPtrTraits, size_t> ts,    const torch::PackedTensorAccessor<scalar_t, 2, torch::RestrictPtrTraits, size_t> hits_t,    torch::PackedTensorAccessor64<int64_t, 1, torch::RestrictPtrTraits> alive_indices,    const scalar_t T_threshold,    const torch::PackedTensorAccessor32<int, 1, torch::RestrictPtrTraits> N_eff_samples,    torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> opacity,    torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> depth,    torch::PackedTensorAccessor<scalar_t, 2, torch::RestrictPtrTraits, size_t> rgb){    const int n = blockIdx.x * blockDim.x + threadIdx.x;    if (n >= alive_indices.size(0)) return;    if (N_eff_samples[n]==0){ // no hit        alive_indices[n] = -1;        return;    }    const size_t r = alive_indices[n]; // ray index    // front to back compositing    int s = 0; scalar_t T = 1-opacity[r];    while (s < N_eff_samples[n]) {        const scalar_t a = 1.0f - __expf(-sigmas[n][s]*deltas[n][s]);        const scalar_t w = a * T;        rgb[r][0] += w*rgbs[n][s][0];        rgb[r][1] += w*rgbs[n][s][1];        rgb[r][2] += w*rgbs[n][s][2];        depth[r] += w*ts[n][s];        opacity[r] += w;        T *= 1.0f-a;        if (T <= T_threshold){ // ray has enough opacity            alive_indices[n] = -1;            break;        }        s++;    }}void composite_test_fw_cu(    const torch::Tensor sigmas,    const torch::Tensor rgbs,    const torch::Tensor deltas,    const torch::Tensor ts,    const torch::Tensor hits_t,    torch::Tensor alive_indices,    const float T_threshold,    const torch::Tensor N_eff_samples,    torch::Tensor opacity,    torch::Tensor depth,    torch::Tensor rgb){    const int N_rays = alive_indices.size(0);    const int threads = 256, blocks = (N_rays+threads-1)/threads;    AT_DISPATCH_FLOATING_TYPES_AND_HALF(sigmas.type(), "composite_test_fw_cu",    ([&] {        composite_test_fw_kernel<scalar_t><<<blocks, threads>>>(            sigmas.packed_accessor<scalar_t, 2, torch::RestrictPtrTraits, size_t>(),            rgbs.packed_accessor<scalar_t, 3, torch::RestrictPtrTraits, size_t>(),            deltas.packed_accessor<scalar_t, 2, torch::RestrictPtrTraits, size_t>(),            ts.packed_accessor<scalar_t, 2, torch::RestrictPtrTraits, size_t>(),            hits_t.packed_accessor<scalar_t, 2, torch::RestrictPtrTraits, size_t>(),            alive_indices.packed_accessor64<int64_t, 1, torch::RestrictPtrTraits>(),            T_threshold,            N_eff_samples.packed_accessor32<int, 1, torch::RestrictPtrTraits>(),            opacity.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            depth.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            rgb.packed_accessor<scalar_t, 2, torch::RestrictPtrTraits, size_t>()        );    }));}//////////////////////  add test uncert //////////////////////////////////template <typename scalar_t>__global__ void composite_test_transient_fw_kernel(    const torch::PackedTensorAccessor<scalar_t, 2, torch::RestrictPtrTraits, size_t> static_sigmas,    const torch::PackedTensorAccessor<scalar_t, 3, torch::RestrictPtrTraits, size_t> static_rgbs,    const torch::PackedTensorAccessor<scalar_t, 2, torch::RestrictPtrTraits, size_t> transient_sigmas,    const torch::PackedTensorAccessor<scalar_t, 3, torch::RestrictPtrTraits, size_t> transient_rgbs,    const torch::PackedTensorAccessor<scalar_t, 2, torch::RestrictPtrTraits, size_t> transient_betas,    const torch::PackedTensorAccessor<scalar_t, 2, torch::RestrictPtrTraits, size_t> deltas,    const torch::PackedTensorAccessor<scalar_t, 2, torch::RestrictPtrTraits, size_t> ts,    const torch::PackedTensorAccessor<scalar_t, 2, torch::RestrictPtrTraits, size_t> hits_t,    torch::PackedTensorAccessor64<int64_t, 1, torch::RestrictPtrTraits> alive_indices,    const scalar_t T_threshold,    const torch::PackedTensorAccessor32<int, 1, torch::RestrictPtrTraits> N_eff_samples,    torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> opacity,    torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> depth,    torch::PackedTensorAccessor<scalar_t, 2, torch::RestrictPtrTraits, size_t> static_rgb,    torch::PackedTensorAccessor<scalar_t, 2, torch::RestrictPtrTraits, size_t> transient_rgb,    torch::PackedTensorAccessor<scalar_t, 1, torch::RestrictPtrTraits, size_t> transient_beta){    const int n = blockIdx.x * blockDim.x + threadIdx.x;    if (n >= alive_indices.size(0)) return;    if (N_eff_samples[n]==0){ // no hit        alive_indices[n] = -1;        return;    }    const size_t r = alive_indices[n]; // ray index    // front to back compositing    int s = 0; scalar_t T = 1-opacity[r];    while (s < N_eff_samples[n]) {        const scalar_t a = 1.0f - __expf(-(static_sigmas[n][s]+transient_sigmas[n][s])*deltas[n][s]);        const scalar_t s_a = 1.0f - __expf(-static_sigmas[n][s]*deltas[n][s]);        const scalar_t t_a = 1.0f - __expf(-transient_sigmas[n][s]*deltas[n][s]);        const scalar_t w = a * T;        const scalar_t s_w = s_a * T;        const scalar_t t_w = t_a * T;        static_rgb[r][0] += s_w*static_rgbs[n][s][0];        static_rgb[r][1] += s_w*static_rgbs[n][s][1];        static_rgb[r][2] += s_w*static_rgbs[n][s][2];        transient_rgb[r][0] += t_w*transient_rgbs[n][s][0];        transient_rgb[r][1] += t_w*transient_rgbs[n][s][1];        transient_rgb[r][2] += t_w*transient_rgbs[n][s][2];        transient_beta[r] += t_w*transient_betas[n][s];        depth[r] += w*ts[n][s];        opacity[r] += w;        T *= 1.0f-a;        if (T <= T_threshold){ // ray has enough opacity            alive_indices[n] = -1;            break;        }        s++;    }}void composite_test_transient_fw_cu(    const torch::Tensor static_sigmas,    const torch::Tensor static_rgbs,    const torch::Tensor transient_sigmas,    const torch::Tensor transient_rgbs,    const torch::Tensor transient_betas,    const torch::Tensor deltas,    const torch::Tensor ts,    const torch::Tensor hits_t,    torch::Tensor alive_indices,    const float T_threshold,    const torch::Tensor N_eff_samples,    torch::Tensor opacity,    torch::Tensor depth,    torch::Tensor static_rgb,    torch::Tensor transient_rgb,    torch::Tensor transient_beta){    const int N_rays = alive_indices.size(0);    const int threads = 256, blocks = (N_rays+threads-1)/threads;    AT_DISPATCH_FLOATING_TYPES_AND_HALF(static_sigmas.type(), "composite_test_transient_fw_cu",    ([&] {        composite_test_transient_fw_kernel<scalar_t><<<blocks, threads>>>(            static_sigmas.packed_accessor<scalar_t, 2, torch::RestrictPtrTraits, size_t>(),            static_rgbs.packed_accessor<scalar_t, 3, torch::RestrictPtrTraits, size_t>(),            transient_sigmas.packed_accessor<scalar_t, 2, torch::RestrictPtrTraits, size_t>(),            transient_rgbs.packed_accessor<scalar_t, 3, torch::RestrictPtrTraits, size_t>(),            transient_betas.packed_accessor<scalar_t, 2, torch::RestrictPtrTraits, size_t>(),            deltas.packed_accessor<scalar_t, 2, torch::RestrictPtrTraits, size_t>(),            ts.packed_accessor<scalar_t, 2, torch::RestrictPtrTraits, size_t>(),            hits_t.packed_accessor<scalar_t, 2, torch::RestrictPtrTraits, size_t>(),            alive_indices.packed_accessor64<int64_t, 1, torch::RestrictPtrTraits>(),            T_threshold,            N_eff_samples.packed_accessor32<int, 1, torch::RestrictPtrTraits>(),            opacity.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            depth.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>(),            static_rgb.packed_accessor<scalar_t, 2, torch::RestrictPtrTraits, size_t>(),            transient_rgb.packed_accessor<scalar_t, 2, torch::RestrictPtrTraits, size_t>(),            transient_beta.packed_accessor<scalar_t, 1, torch::RestrictPtrTraits, size_t>()        );    }));}